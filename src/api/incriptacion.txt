// src/api/apiClient.js
import { API_URL } from '../utils/env';
import { cryptoManager } from '../utils/crypto';

class ApiClient {
  constructor() {
    this.baseURL = API_URL;
    this.refreshing = null;
  }

  getToken() {
    return localStorage.getItem('accessToken');
  }

  getRefreshToken() {
    return localStorage.getItem('refreshToken');
  }

  setTokens(accessToken, refreshToken) {
    localStorage.setItem('accessToken', accessToken);
    if (refreshToken) {
      localStorage.setItem('refreshToken', refreshToken);
    }
  }

  clearTokens() {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }

  redirectToLogin() {
    this.clearTokens();
    window.location.replace('/login');
  }

  async ensureToken() {
    let token = this.getToken();
    if (token) return token;

    if (!this.refreshing) {
      this.refreshing = this._refreshToken();
    }
    try {
      token = await this.refreshing;
    } catch (err) {
      this.redirectToLogin();
      throw err;
    }
    return token;
  }

  async _refreshToken() {
    const refreshToken = this.getRefreshToken();

    if (!refreshToken) {
      console.warn('No refresh token available - redirecting to login');
      this.redirectToLogin();
      throw new Error('No refresh token available');
    }

    try {
      const res = await fetch(`${this.baseURL}/auth/refreshToken`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${refreshToken}`,
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });

      if (!res.ok) {
        const errData = await res.json().catch(() => ({}));
        console.error('Refresh failed:', errData.message);
        this.redirectToLogin();
        throw new Error(errData.message || 'Refresh failed');
      }

      const { accessToken, refreshToken: newRefreshToken } = await res.json();

      if (!accessToken) {
        this.redirectToLogin();
        throw new Error('No access token in response');
      }

      this.setTokens(accessToken, newRefreshToken || refreshToken);

      console.log('Token refreshed successfully');
      return accessToken;
    } catch (err) {
      this.redirectToLogin();
      throw err;
    } finally {
      this.refreshing = null;
    }
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...options,
      headers: { 'Content-Type': 'application/json', ...options.headers },
      credentials: 'include',
    };

    // === RUTAS PÃšBLICAS: NO requieren token ni refresh ===
    const publicEndpoints = [
      '/auth/login',
      '/auth/register',
      '/auth/refreshToken'
    ];
    const isPublic = publicEndpoints.some(path => endpoint.startsWith(path));

    if (!isPublic) {
      const token = await this.ensureToken().catch(() => {
        this.redirectToLogin();
        return null;
      });
      if (token) {
        config.headers['Authorization'] = `Bearer ${token}`;
      }
    }

    // === INTEGRACIÃ“N CRYPTO ===
    // Solo el handshake estÃ¡ exento de encriptaciÃ³n
    const isHandshake = endpoint.includes('/crypto/handshake');
    
    // 1. Asegurar sesiÃ³n crypto para TODAS las rutas protegidas (excepto handshake)
    if (!isHandshake) {
        await cryptoManager.ensureSession();
    }
    
    // 2. Agregar headers de sesiÃ³n si existen (para GETs y otros mÃ©todos sin body)
    if (!isHandshake && cryptoManager.sessionId) {
        config.headers['X-Session-Id'] = cryptoManager.sessionId;
        // Incrementamos nonce localmente para el header, pero solo si NO vamos a encriptar body
        // Si encriptamos body, el nonce va dentro del payload cifrado.
        // Si es GET, va en el header.
        if (!config.body || config.method === 'GET' || config.method === 'HEAD') {
             cryptoManager.nonce++;
             config.headers['X-Nonce'] = cryptoManager.nonce.toString();
        }
    }
    
    // 3. Si no es handshake, encriptar body (solo si hay body y es JSON)
    if (!isHandshake && config.body && config.headers['Content-Type'] === 'application/json') {
      try {
        const data = JSON.parse(config.body);
        const encrypted = await cryptoManager.encrypt(data);
        config.body = JSON.stringify(encrypted);
      } catch (error) {
        console.error('Encryption failed:', error);
        // Si falla encriptaciÃ³n por falta de sesiÃ³n, intentar handshake y reintentar
        if (!cryptoManager.sessionId) {
           await cryptoManager.performHandshake();
           const data = JSON.parse(options.body || '{}'); // Recupear data original
           const encrypted = await cryptoManager.encrypt(data);
           config.body = JSON.stringify(encrypted);
        } else {
           throw error;
        }
      }
    }

    // DEBUG: Ver quÃ© headers se estÃ¡n enviando realmente
    if (!isHandshake) {
        console.log(`ðŸš€ [${config.method || 'GET'}] ${endpoint} Headers:`, config.headers);
        if (config.body) console.log(`ðŸ“¦ Body Encrypted:`, config.body.substring(0, 50) + '...');
    }

    let res = await fetch(url, config);

    // === MANEJO DE 401 ===
    if (res.status === 401 && !options._retry) {
      // Si es login o register â†’ NO intentar refresh, solo devolver error
      if (endpoint.startsWith('/auth/login') || endpoint.startsWith('/auth/register')) {
        const errData = await res.json().catch(() => ({}));
        // Intentar desencriptar error si viene cifrado
        if (errData.cipherText) {
             try {
               const decryptedErr = await cryptoManager.decrypt(errData);
               throw new Error(decryptedErr.message || 'Credenciales invÃ¡lidas');
             } catch (e) {
               throw new Error(errData.message || 'Credenciales invÃ¡lidas');
             }
        }
        throw new Error(errData.message || 'Credenciales invÃ¡lidas');
      }

      // Si es refreshToken fallido â†’ redirigir
      if (endpoint.includes('refreshToken')) {
        this.redirectToLogin();
        throw new Error('SesiÃ³n expirada');
      }

      // Para cualquier otra ruta protegida â†’ intentar refresh
      console.log(`Token expired on ${endpoint}, attempting refresh...`);
      try {
        await this._refreshToken();
        return this.request(endpoint, { ...options, _retry: true });
      } catch (err) {
        this.redirectToLogin();
        throw err;
      }
    }

    // === ERRORES GENERALES ===
    if (!res.ok) {
      let errData;
      try {
        errData = await res.json();
        // Intentar desencriptar error
        if (errData.cipherText) {
          errData = await cryptoManager.decrypt(errData);
        }
      } catch {
        errData = {};
      }
      
      // Si el error es "Encrypted payload required" O "Invalid or expired sessionId", significa que perdimos sesiÃ³n crypto
      if (errData.message && (errData.message.includes('Encrypted payload required') || errData.message.includes('Invalid or expired sessionId')) && !options._retryCrypto) {
         console.warn('Crypto session lost/invalid, re-handshaking...');
         cryptoManager.reset();
         await cryptoManager.performHandshake();
         return this.request(endpoint, { ...options, _retryCrypto: true });
      }

      throw new Error(errData.message || `Error ${res.status}`);
    }

    // === DESENCRIPTAR RESPUESTA ===
    const data = await res.json();
    
    if (data.cipherText && data.iv && data.tag) {
      try {
        return await cryptoManager.decrypt(data);
      } catch (error) {
        console.error('Decryption failed:', error);
        throw new Error('Error de seguridad al procesar respuesta');
      }
    }

    return data;
  }

  get = (endpoint) => this.request(endpoint, { method: 'GET' });
  post = (endpoint, data) => this.request(endpoint, { method: 'POST', body: JSON.stringify(data) });
  put = (endpoint, data) => this.request(endpoint, { method: 'PUT', body: JSON.stringify(data) });
  delete = (endpoint) => this.request(endpoint, { method: 'DELETE' });
}

export const api = new ApiClient();

